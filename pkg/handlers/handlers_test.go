package handlers

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
	"time"

	"github.com/google/uuid"
)

const (
	validUID string = "dd37122b-daaf-4d75-9250-c0747e9c5c47"
)

func TestStatus(t *testing.T) {
	testCases := []struct {
		name           string
		isBusy         bool
		isError        bool
		errFileContent string
		expectedCode   int
		expectedBody   string
	}{
		{
			name:         "Service is ready, HTTP 200",
			isBusy:       false,
			isError:      false,
			expectedCode: 200,
			expectedBody: ready,
		},
		{
			name:         "Service is busy, HTTP 409",
			isBusy:       true,
			isError:      false,
			expectedCode: 409,
			expectedBody: validUID + " still running",
		},
		{
			name:           "Service is in error, HTTP 500",
			isBusy:         false,
			isError:        true,
			expectedCode:   500,
			errFileContent: "{\"ID\":\"" + validUID + "\",\"ProfilingRuns\":[{\"Type\":\"Kubelet\",\"Successful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Successful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}",
			expectedBody:   validUID + " failed",
		},
		{
			name:           "Service is in error, error file unreadable, HTTP 500",
			isBusy:         false,
			isError:        true,
			expectedCode:   500,
			errFileContent: "{\"ID" + validUID + "\",\"ProfilingRuns\":[{\"Type\":\"Kubelet\",\"Successful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Successful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}}",
			expectedBody:   "unable to read error file",
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			r := httptest.NewRequest("GET", "http://localhost/status", nil)
			w := httptest.NewRecorder()
			h := NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1")
			if tc.isBusy {
				h.onGoingRunId = validUID
			}
			if tc.isError {
				// prepare an error file
				errorFile := "/tmp/agent.err"
				err := os.WriteFile(errorFile, []byte(tc.errFileContent), 0644)
				if err != nil {
					t.Error(err)
				}
				defer func() {
					if os.Remove(errorFile) != nil {
						t.Error(err)
					}
				}()
			}
			h.Status(w, r)
			resp := w.Result()

			if resp.StatusCode != tc.expectedCode {
				t.Errorf("Expected status code %d but was %d", tc.expectedCode, resp.StatusCode)
			}
		})
	}
}

func TestCreateAndSendUID(t *testing.T) {

	testCases := []struct {
		name         string
		expectedCode int
	}{
		{
			name:         "Nominal case, no errors",
			expectedCode: 200,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			r := httptest.NewRequest("GET", "http://localhost/pprof", nil)
			w := httptest.NewRecorder()

			run, err := createAndSendUID(w, r)
			if err != nil {
				t.Errorf("error calling createAndSendUID : %v", err)
			}
			if run.ID == uuid.Nil {
				t.Error("run UID is nil when it shouldnt")
			}
			if len(run.ProfilingRuns) != 0 {
				t.Error("run shouldnt have and profiling results")
			}
			resp := w.Result()
			defer resp.Body.Close()
			if resp.StatusCode != tc.expectedCode {
				t.Errorf("Expected status code %d but was %d", tc.expectedCode, resp.StatusCode)
			}
			bodyContent, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				t.Errorf("error reading response body : %v", err)
			}
			responseRun := Run{}
			err = json.Unmarshal(bodyContent, &responseRun)
			if err != nil {
				t.Errorf("error unmarshalling response body : %v", err)
			}
			if responseRun.ID != run.ID {
				t.Errorf("The UID returned in the HTTP response should be the same as the one generated by createAndSendUID:\n run.ID=%v, response body contained %v", run.ID, responseRun.ID)
			}
		})
	}
}

func TestErrorFileExists(t *testing.T) {

	testCases := []struct {
		name     string
		handler  Handlers
		expected bool
	}{
		{
			name:     "file doesnt exist, return false",
			handler:  *NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1"),
			expected: false,
		},
		{
			name:     "file exists, return true",
			handler:  *NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1"),
			expected: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.expected {
				// prepare an error file
				errorFile := "/tmp/agent.err"
				fileContent := "{\"ID\":\"1234\",\"ProfilingRuns\":[{\"Type\":\"Kubelet\",\"Successful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Successful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}"
				err := os.WriteFile(errorFile, []byte(fileContent), 0644)
				if err != nil {
					t.Error(err)
				}
				defer func() {
					if os.Remove(errorFile) != nil {
						t.Error(err)
					}
				}()
			}

			if tc.expected != tc.handler.errorFileExists() {
				t.Errorf("Expected errorFileExists = %v but was %v", tc.expected, tc.handler.errorFileExists())
			}
		})
	}
}

func TestReadUidFromFile(t *testing.T) {
	// prepare an error file
	normalErrorFile := "/tmp/agent.err"
	fileContent := Run{
		ID:            uuid.MustParse(validUID),
		ProfilingRuns: []ProfilingRun{},
	}
	jsonFileContent, err := json.Marshal(fileContent)
	if err != nil {
		t.Error(err)
	}
	err = os.WriteFile(normalErrorFile, jsonFileContent, 0644)
	if err != nil {
		t.Error(err)
	}
	defer func() {
		if os.Remove(normalErrorFile) != nil {
			t.Errorf("Unable to delete %s", normalErrorFile)
		}
	}()

	unreadableErrorFile := "/tmp/noReadAgent.err"
	err = os.WriteFile(unreadableErrorFile, []byte(jsonFileContent), 0333)
	if err != nil {
		t.Error(err)
	}
	defer func() {
		if os.Remove(unreadableErrorFile) != nil {
			t.Error(err)
		}
	}()
	// prepare an error file
	unmarshallableErrorFile := "/tmp/invalidJsonAgent.err"
	unmarshallableContent := "{\"ID " + validUID + "\",\"ProfilingRuns\":{\"Type\":\"Kubelet\",\"Successful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Successful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}"
	err = os.WriteFile(unmarshallableErrorFile, []byte(unmarshallableContent), 0644)
	if err != nil {
		t.Error(err)
	}
	defer func() {
		if os.Remove(unmarshallableErrorFile) != nil {
			t.Error(err)
		}
	}()

	testCases := []struct {
		name          string
		errorFile     string
		expectedError bool
		expectedId    string
	}{
		{
			name:          "error file with correct content returns expected uid",
			errorFile:     normalErrorFile,
			expectedError: false,
			expectedId:    validUID,
		},
		{
			name:          "error file with unmarshallable content returns expected error",
			errorFile:     unmarshallableErrorFile,
			expectedError: true,
			expectedId:    "",
		},
		{
			name:          "error file with no read permission returns expected error",
			errorFile:     unreadableErrorFile,
			expectedError: true,
			expectedId:    "",
		},
		{
			name:          "error file doesnt exist returns expected uid",
			errorFile:     "/tmp/doesntexist.err",
			expectedError: true,
			expectedId:    "",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			id, err := readUidFromFile(tc.errorFile)
			if tc.expectedId != id {
				t.Errorf("expected ID %s but was %s", tc.expectedId, id)
			}
			if err != nil && !tc.expectedError {
				t.Errorf("Error was not expected: %v", err)
			}
			if err == nil && tc.expectedError {
				t.Error("expected an error to occur, but nothing bad happened")
			}
		})
	}
}

func TestHandleProfiling(t *testing.T) {

	testCases := []struct {
		name           string
		serverState    string
		errFileContent string
		expectedCode   int
	}{
		{
			name:         "Server is ready creates lock, triggers pprof for crio+kubelet and answers 200",
			serverState:  "ready",
			expectedCode: http.StatusOK,
		},
		{
			name:           "Server is in error should send 500 immediately",
			serverState:    "error",
			errFileContent: "{\"ID\":\"" + validUID + "\",\"ProfilingRuns\":[{\"Type\":\"Kubelet\",\"Successful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Successful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}",
			expectedCode:   http.StatusInternalServerError,
		},
		{
			name:           "Server is in error, error file unreadable should send 500 immediately",
			serverState:    "error",
			errFileContent: "{\"ID" + validUID + "\",\"ProfilingRuns\":{\"Type\":\"Kubelet\",\"Successful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Successful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}",
			expectedCode:   http.StatusInternalServerError,
		},
		{
			name:         "Server is busy should send 409 immediately",
			serverState:  "busy",
			expectedCode: http.StatusConflict,
		},
	}
	for _, tc := range testCases {

		t.Run(tc.name, func(t *testing.T) {
			h := NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1")
			r := httptest.NewRequest("GET", "http://localhost/status", nil)
			w := httptest.NewRecorder()
			if tc.serverState == "busy" {
				h.mux.Lock()
				h.
					onGoingRunId = validUID
			}
			if tc.serverState == "error" {
				// prepare an error file
				errorFile := "/tmp/agent.err"
				err := os.WriteFile(errorFile, []byte(tc.errFileContent), 0644)
				if err != nil {
					t.Error(err)
				}
				defer func() {
					if os.Remove(errorFile) != nil {
						t.Log("unable to remove file, already removed")
					}
				}()
			}
			h.HandleProfiling(w, r)
			resp := w.Result()

			if resp.StatusCode != tc.expectedCode {
				t.Errorf("Expected status code %d but was %d", tc.expectedCode, resp.StatusCode)
			}
			if tc.serverState == "ready" {
				if h.onGoingRunId == "" {
					t.Error("expected lock to be created and ongoingRunId not to be empty")
				}
			} else if tc.serverState == "busy" {
				if h.onGoingRunId != validUID {
					t.Errorf("Expected lock to be locked, with ongoingRunId = %s, but was empty", h.onGoingRunId)

				}
			} else if tc.serverState == "error" {
				if h.onGoingRunId != "" {
					t.Errorf("Expected lock to be unlocked, but had ongoingRunId = %s", h.onGoingRunId)

				}
			}
		})
	}
}

func TestProcessResults(t *testing.T) {
	h := NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1")

	crioRunOK := ProfilingRun{
		Type:       CRIORun,
		Successful: true,
		BeginDate:  time.Now(),
		EndDate:    time.Now(),
		Error:      "",
	}
	crioRunKO := ProfilingRun{
		Type:       CRIORun,
		Successful: false,
		BeginDate:  time.Now(),
		EndDate:    time.Now(),
		Error:      "fake error",
	}
	kubeletRunOK := ProfilingRun{
		Type:       KubeletRun,
		Successful: true,
		BeginDate:  time.Now(),
		EndDate:    time.Now(),
		Error:      "",
	}
	kubeletRunKO := ProfilingRun{
		Type:       KubeletRun,
		Successful: false,
		BeginDate:  time.Now(),
		EndDate:    time.Now(),
		Error:      "fake error",
	}
	chanAllOK := make(chan ProfilingRun, 2)
	chanAllOK <- kubeletRunOK
	chanAllOK <- crioRunOK

	chanCrioKO := make(chan ProfilingRun, 2)
	chanCrioKO <- kubeletRunOK
	chanCrioKO <- crioRunKO

	chanKubeletKO := make(chan ProfilingRun, 2)
	chanKubeletKO <- kubeletRunKO
	chanKubeletKO <- crioRunOK

	chanOnlyCrio := make(chan ProfilingRun, 1)
	chanOnlyCrio <- crioRunOK

	testCases := []struct {
		name                   string
		channel                chan ProfilingRun
		expectedLock           bool
		expectedError          bool
		expectedTimeout        bool
		expectedCrioSuccess    bool
		expectedKubeletSuccess bool
		expectedRunID          string
	}{
		{
			name:                   "channel with both results OK releases the lock",
			channel:                chanAllOK,
			expectedLock:           false,
			expectedError:          false,
			expectedTimeout:        false,
			expectedCrioSuccess:    true,
			expectedKubeletSuccess: true,
			expectedRunID:          validUID,
		},
		{
			name:                   "channel with crio result KO releases the lock and creates error file",
			channel:                chanCrioKO,
			expectedLock:           false,
			expectedError:          true,
			expectedTimeout:        false,
			expectedCrioSuccess:    false,
			expectedKubeletSuccess: true,
			expectedRunID:          validUID,
		},
		{
			name:                   "channel with kubelet result KO releases the lock and creates error file",
			channel:                chanKubeletKO,
			expectedLock:           false,
			expectedError:          true,
			expectedTimeout:        false,
			expectedCrioSuccess:    true,
			expectedKubeletSuccess: false,
			expectedRunID:          validUID,
		},
		{
			name:                   "channel with only crio result should be unstuck after 40s with error file",
			channel:                chanOnlyCrio,
			expectedLock:           false,
			expectedError:          true,
			expectedTimeout:        true,
			expectedCrioSuccess:    true,
			expectedKubeletSuccess: false,
			expectedRunID:          validUID,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			run := Run{
				ID:            uuid.MustParse(validUID),
				ProfilingRuns: []ProfilingRun{},
			}
			h.mux.Lock()
			h.onGoingRunId = validUID
			defer cleanup(t)
			h.processResults(run, tc.channel)
			if h.onGoingRunId != "" && !tc.expectedLock {
				t.Errorf("Shouldnt be locked but was locked by " + h.onGoingRunId)
			}
			if h.onGoingRunId == "" && tc.expectedLock {
				t.Errorf("Should be locked but wasnt")
			}
			if !tc.expectedError {
				_, err := os.Stat("/tmp/" + validUID + ".log")
				if err != nil {
					t.Errorf("Expected log file /tmp/%s.log but file wasnt there", validUID)
				}
				theRun, err := readRunFromFile("/tmp/" + validUID + ".log")
				if err != nil {
					t.Errorf("error reading file /tmp/%s.log: %v", validUID, err)
				}
				if theRun.ID.String() != tc.expectedRunID {
					t.Errorf("Expected log file /tmp/%s.log to contain run ID %s but was %s", validUID, theRun.ID.String(), tc.expectedRunID)
				}
				for _, aProfilingRun := range theRun.ProfilingRuns {
					if aProfilingRun.Type == CRIORun {
						if aProfilingRun.Successful != tc.expectedCrioSuccess {
							t.Errorf("Expected log file /tmp/%s.log to contain crio run success = %t, but was %t", validUID, tc.expectedCrioSuccess, aProfilingRun.Successful)
						}
					}
					if aProfilingRun.Type == KubeletRun {
						if aProfilingRun.Successful != tc.expectedKubeletSuccess {
							t.Errorf("Expected log file /tmp/%s.log to contain kubelet run success = %t, but was %t", validUID, tc.expectedKubeletSuccess, aProfilingRun.Successful)
						}
					}
				}
			} else {
				_, err := os.Stat("/tmp/agent.err")
				if err != nil {
					t.Errorf("Expected error file /tmp/agent.err but file wasnt there")
				}
				theRun, err := readRunFromFile("/tmp/agent.err")
				if err == nil {
					if theRun.ID.String() != tc.expectedRunID {
						t.Errorf("Expected log file /tmp/agent.err to contain run ID %s but was %s", theRun.ID.String(), tc.expectedRunID)
					}
					for _, aProfilingRun := range theRun.ProfilingRuns {
						if aProfilingRun.Type == CRIORun {
							if aProfilingRun.Successful != tc.expectedCrioSuccess {
								t.Errorf("Expected log file /tmp/agent.err to contain crio run success = %t, but was %t", tc.expectedCrioSuccess, aProfilingRun.Successful)
							}
						}
						if aProfilingRun.Type == KubeletRun {
							if aProfilingRun.Successful != tc.expectedKubeletSuccess {
								t.Errorf("Expected log file /tmp/agent.err to contain kubelet run success = %t, but was %t", tc.expectedKubeletSuccess, aProfilingRun.Successful)
							}
						}
						if aProfilingRun.Type == UnknownRun && !tc.expectedTimeout {
							t.Error("timeout when none was expected")
						}
					}
				}
			}
		})
	}
}

func cleanup(t *testing.T) {
	_, err := os.Stat("/tmp/agent.err")
	if err == nil {
		if err := os.Remove("/tmp/agent.err"); err != nil {
			t.Error(err)
		}
	}
	_, err = os.Stat("/tmp/" + validUID + ".log")
	if err == nil {
		if err := os.Remove("/tmp/" + validUID + ".log"); err != nil {
			t.Error(err)
		}
	}
}

func readRunFromFile(fileName string) (Run, error) {
	var run *Run = &Run{}
	contents, err := ioutil.ReadFile(fileName)
	if err != nil {
		return *run, err
	}
	err = json.Unmarshal(contents, run)
	if err != nil {
		return *run, err
	}
	return *run, nil
}
