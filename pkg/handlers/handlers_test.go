package handlers

import (
	"encoding/json"
	"io/ioutil"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/google/uuid"
)

func TestStatus(t *testing.T) {
	testCases := []struct {
		name         string
		isBusy       bool
		isError      bool
		expectedCode int
		expectedBody string
	}{
		{
			name:         "Service is ready, HTTP 200",
			isBusy:       false,
			isError:      false,
			expectedCode: 200,
			expectedBody: ready,
		},
		{
			name:         "Service is busy, HTTP 409",
			isBusy:       true,
			isError:      false,
			expectedCode: 409,
			expectedBody: "1234 still running",
		},
		{
			name:         "Service is in error, HTTP 500",
			isBusy:       false,
			isError:      true,
			expectedCode: 500,
			expectedBody: "1234 failed",
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			r := httptest.NewRequest("GET", "http://localhost/status", nil)
			w := httptest.NewRecorder()
			h := NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1")
			if tc.isBusy {
				h.onGoingRunId = "1234"
			}
			if tc.isError {
				// prepare an error file
				errorFile := "/tmp/agent.err"
				fileContent := "{\"ID\":\"1234\",\"ProfilingRuns\":[{\"Type\":\"Kubelet\",\"Sucessful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Sucessful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}"
				err := os.WriteFile(errorFile, []byte(fileContent), 0644)
				if err != nil {
					t.Error(err)
				}
				defer func() {
					if os.Remove(errorFile) != nil {
						t.Error(err)
					}
				}()
			}
			h.Status(w, r)
			resp := w.Result()

			if resp.StatusCode != tc.expectedCode {
				t.Errorf("Expected status code %d but was %d", tc.expectedCode, resp.StatusCode)
			}
		})
	}
}

func TestCreateAndSendUID(t *testing.T) {

	testCases := []struct {
		name         string
		expectedCode int
	}{
		{
			name:         "Nominal case, no errors",
			expectedCode: 200,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			r := httptest.NewRequest("GET", "http://localhost/pprof", nil)
			w := httptest.NewRecorder()

			run, err := createAndSendUID(w, r)
			if err != nil {
				t.Errorf("error calling createAndSendUID : %v", err)
			}
			if run.ID == uuid.Nil {
				t.Error("run UID is nil when it shouldnt")
			}
			if len(run.ProfilingRuns) != 0 {
				t.Error("run shouldnt have and profiling results")
			}
			resp := w.Result()
			defer resp.Body.Close()
			if resp.StatusCode != tc.expectedCode {
				t.Errorf("Expected status code %d but was %d", tc.expectedCode, resp.StatusCode)
			}
			bodyContent, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				t.Errorf("error reading response body : %v", err)
			}
			responseRun := Run{}
			err = json.Unmarshal(bodyContent, &responseRun)
			if err != nil {
				t.Errorf("error unmarshalling response body : %v", err)
			}
			if responseRun.ID != run.ID {
				t.Errorf("The UID returned in the HTTP response should be the same as the one generated by createAndSendUID:\n run.ID=%v, response body contained %v", run.ID, responseRun.ID)
			}
		})
	}
}

func TestErrorFileExists(t *testing.T) {

	testCases := []struct {
		name     string
		handler  Handlers
		expected bool
	}{
		{
			name:     "file doesnt exist, return false",
			handler:  *NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1"),
			expected: false,
		},
		{
			name:     "file exists, return true",
			handler:  *NewHandlers("abc", "/tmp", "/tmp/fakeSocket", "127.0.0.1"),
			expected: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			if tc.expected {
				// prepare an error file
				errorFile := "/tmp/agent.err"
				fileContent := "{\"ID\":\"1234\",\"ProfilingRuns\":[{\"Type\":\"Kubelet\",\"Sucessful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Sucessful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}"
				err := os.WriteFile(errorFile, []byte(fileContent), 0644)
				if err != nil {
					t.Error(err)
				}
				defer func() {
					if os.Remove(errorFile) != nil {
						t.Error(err)
					}
				}()
			}

			if tc.expected != tc.handler.errorFileExists() {
				t.Errorf("Expected errorFileExists = %v but was %v", tc.expected, tc.handler.errorFileExists())
			}
		})
	}
}

func TestReadUidFromFile(t *testing.T) {
	// prepare an error file
	normalErrorFile := "/tmp/agent.err"
	fileContent := Run{
		ID:            uuid.MustParse("dd37122b-daaf-4d75-9250-c0747e9c5c47"),
		ProfilingRuns: []ProfilingRun{},
	}
	jsonFileContent, err := json.Marshal(fileContent)
	if err != nil {
		t.Error(err)
	}
	err = os.WriteFile(normalErrorFile, jsonFileContent, 0644)
	if err != nil {
		t.Error(err)
	}
	defer func() {
		if os.Remove(normalErrorFile) != nil {
			t.Error(err)
		}
	}()

	unreadableErrorFile := "/tmp/noReadAgent.err"
	err = os.WriteFile(unreadableErrorFile, []byte(jsonFileContent), 0333)
	if err != nil {
		t.Error(err)
	}
	defer func() {
		if os.Remove(unreadableErrorFile) != nil {
			t.Error(err)
		}
	}()
	// prepare an error file
	unmarshallableErrorFile := "/tmp/KOagent.err"
	unmarshallableContent := "{\"ID dd37122b-daaf-4d75-9250-c0747e9c5c47\",\"ProfilingRuns\":{\"Type\":\"Kubelet\",\"Sucessful\":false,\"BeginDate\":\"2022-03-03T10:10:17.188097819Z\",\"EndDate\":\"2022-03-03T10:10:47.211572681Z\",\"Error\":\"fake error\"},{\"Type\":\"CRIO\",\"Sucessful\":true,\"BeginDate\":\"2022-03-03T10:10:17.188499431Z\",\"EndDate\":\"2022-03-03T10:10:47.215840909Z\",\"Error\":null}]}"
	err = os.WriteFile(unmarshallableErrorFile, []byte(unmarshallableContent), 0644)
	if err != nil {
		t.Error(err)
	}
	defer func() {
		if os.Remove(unmarshallableErrorFile) != nil {
			t.Error(err)
		}
	}()

	testCases := []struct {
		name          string
		errorFile     string
		expectedError bool
		expectedId    string
	}{
		{
			name:          "error file with correct content returns expected uid",
			errorFile:     normalErrorFile,
			expectedError: false,
			expectedId:    "dd37122b-daaf-4d75-9250-c0747e9c5c47",
		},
		{
			name:          "error file with unmarshallable content returns expected error",
			errorFile:     unmarshallableErrorFile,
			expectedError: true,
			expectedId:    "",
		},
		{
			name:          "error file with no read permission returns expected error",
			errorFile:     unreadableErrorFile,
			expectedError: true,
			expectedId:    "",
		},
		{
			name:          "error file doesnt exist returns expected uid",
			errorFile:     "/tmp/doesntexist.err",
			expectedError: true,
			expectedId:    "",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			id, err := readUidFromFile(tc.errorFile)
			if tc.expectedId != id {
				t.Errorf("expected ID %s but was %s", tc.expectedId, id)
			}
			if err != nil && !tc.expectedError {
				t.Errorf("Error was not expected: %v", err)
			}
			if err == nil && tc.expectedError {
				t.Error("expected an error to occur, but nothing bad happened")
			}
		})
	}
}
